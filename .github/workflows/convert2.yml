name: ZKEEN dat → mihomo rules (geofileviewer correct, FINAL)

on:
  workflow_dispatch:
 
permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.21"

      - name: Prepare directories
        run: |
          mkdir -p tmp rules/geosite rules/geoip

      - name: Install tools
        run: |
          go install github.com/urlesistiana/v2dat@latest
          go install github.com/metacubex/mihomo@latest

      - name: Download dat files
        run: |
          curl -fsSL -o tmp/geosite.dat \
            https://github.com/jameszeroX/zkeen-domains/releases/latest/download/zkeen.dat
          curl -fsSL -o tmp/geoip.dat \
            https://github.com/jameszeroX/zkeen-ip/releases/latest/download/zkeenip.dat

      # =========================
      # GEOIP (корректно через v2dat)
      # =========================
      - name: Build geoip rules
        run: |
          mkdir -p tmp/geoip
          v2dat unpack geoip -o tmp/geoip tmp/geoip.dat

          rm -rf rules/geoip/*
          for f in tmp/geoip/*.txt; do
            name=$(basename "$f" .txt | sed 's/^geoip_//')

            grep -v '^#' "$f" | grep -v '^$' > "rules/geoip/$name.txt"

            echo "payload:" > "rules/geoip/$name.yaml"
            sed 's/^/  - /' "rules/geoip/$name.txt" >> "rules/geoip/$name.yaml"

            mihomo convert-ruleset ipcidr text \
              "rules/geoip/$name.txt" \
              "rules/geoip/$name.mrs" || true
          done

      # =========================
      # GEOSITE (ПРАВИЛЬНЫЙ protobuf)
      # =========================
      - name: Parse geosite.dat (protobuf-correct, viewer logic)
        run: |
          node << 'EOF'
          const fs = require('fs');

          function readVarint(buf, pos) {
            let result = 0, shift = 0;
            while (true) {
              const b = buf[pos++];
              result |= (b & 0x7f) << shift;
              if ((b & 0x80) === 0) break;
              shift += 7;
            }
            return [result, pos];
          }

          function safeName(s) {
            return /^[a-z0-9_-]+$/i.test(s);
          }

          const data = fs.readFileSync('tmp/geosite.dat');
          let pos = 0;

          fs.mkdirSync('rules/geosite', { recursive: true });

          while (pos < data.length) {
            const tag = data[pos++];
            const field = tag >> 3;
            const wire = tag & 7;

            // top-level must be: field 1, wire 2 (GeoSite)
            if (field !== 1 || wire !== 2) {
              // skip unknown
              if (wire === 0) [, pos] = readVarint(data, pos);
              else if (wire === 2) {
                let len; [len, pos] = readVarint(data, pos);
                pos += len;
              }
              continue;
            }

            let len;
            [len, pos] = readVarint(data, pos);
            const block = data.slice(pos, pos + len);
            pos += len;

            let i = 0;
            let name = null;
            const domains = [];

            while (i < block.length) {
              const t = block[i++];
              const f = t >> 3;
              const w = t & 7;
              if (w !== 2) continue;

              let l;
              [l, i] = readVarint(block, i);
              const v = block.slice(i, i + l);
              i += l;

              // country_code
              if (f === 1) {
                name = v.toString('utf8').toLowerCase();
              }

              // domain
              if (f === 2) {
                let di = 0;
                while (di < v.length) {
                  const dt = v[di++];
                  const df = dt >> 3;
                  const dw = dt & 7;
                  if (df === 1 && dw === 2) {
                    let dl;
                    [dl, di] = readVarint(v, di);
                    domains.push(v.slice(di, di + dl).toString('utf8'));
                    di += dl;
                  } else {
                    di++;
                  }
                }
              }
            }

            if (!name || !safeName(name) || domains.length === 0) continue;

            const uniq = [...new Set(domains)].sort();
            const txt = [];
            const yaml = ['payload:'];

            for (const d of uniq) {
              txt.push(d);
              yaml.push(`  - +.${d}`);
            }

            fs.writeFileSync(`rules/geosite/${name}.txt`, txt.join('\n') + '\n');
            fs.writeFileSync(`rules/geosite/${name}.yaml`, yaml.join('\n') + '\n');
          }
          EOF

      - name: Build geosite MRS
        run: |
          for f in rules/geosite/*.txt; do
            name=$(basename "$f" .txt)
            mihomo convert-ruleset domain text \
              "$f" \
              "rules/geosite/$name.mrs" || true
          done

      - name: Commit & push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add rules/
          if git diff --staged --quiet; then
            echo "No changes"
          else
            git commit -m "chore: rebuild rules (protobuf-correct geosite)"
            git push
          fi
