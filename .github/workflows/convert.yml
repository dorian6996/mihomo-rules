name: ZKEEN dat → mihomo rules (geofileviewer-correct)

on:
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * *"

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      # -------------------------
      # ENV
      # -------------------------
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.21"

      - name: Prepare directories
        run: |
          mkdir -p tmp rules/geosite rules/geoip

      - name: Install tools
        run: |
          go install github.com/urlesistiana/v2dat@latest
          go install github.com/metacubex/mihomo@latest

      - name: Download dat files
        run: |
          curl -fsSL -o tmp/geosite.dat \
            https://github.com/jameszeroX/zkeen-domains/releases/latest/download/zkeen.dat
          curl -fsSL -o tmp/geoip.dat \
            https://github.com/jameszeroX/zkeen-ip/releases/latest/download/zkeenip.dat

      # =========================
      # GEOIP (через v2dat, БЕЗ geoip_ в имени)
      # =========================
      - name: Build geoip rules
        run: |
          mkdir -p tmp/geoip
          v2dat unpack geoip -o tmp/geoip tmp/geoip.dat

          rm -rf rules/geoip/*
          for f in tmp/geoip/*.txt; do
            name=$(basename "$f" .txt | sed 's/^geoip_//')

            grep -v '^#' "$f" | grep -v '^$' > "rules/geoip/$name.txt"

            echo "payload:" > "rules/geoip/$name.yaml"
            sed 's/^/  - /' "rules/geoip/$name.txt" >> "rules/geoip/$name.yaml"

            mihomo convert-ruleset ipcidr text \
              "rules/geoip/$name.txt" \
              "rules/geoip/$name.mrs" || true
          done

      # =========================
      # GEOSITE (ЧИСТАЯ логика geofileviewer)
      # =========================
      - name: Parse geosite.dat (viewer-accurate)
        run: |
          node << 'EOF'
          const fs = require('fs');

          function readVarint(buf, pos) {
            let result = 0, shift = 0;
            while (true) {
              const b = buf[pos++];
              result |= (b & 0x7f) << shift;
              if ((b & 0x80) === 0) break;
              shift += 7;
            }
            return [result, pos];
          }

          function safeName(s) {
            return /^[a-z0-9_-]+$/i.test(s);
          }

          const data = fs.readFileSync('tmp/geosite.dat');
          let pos = 0;

          fs.mkdirSync('rules/geosite', { recursive: true });

          while (pos < data.length) {
            let size;
            try {
              [size, pos] = readVarint(data, pos);
            } catch {
              break;
            }

            const block = data.slice(pos, pos + size);
            pos += size;

            let i = 0;
            let name = null;
            const domains = [];

            while (i < block.length) {
              const tag = block[i++];
              const field = tag >> 3;
              const wire = tag & 7;

              if (wire !== 2) continue;

              let len;
              [len, i] = readVarint(block, i);
              const value = block.slice(i, i + len);
              i += len;

              // field 1 = country_code (group name)
              if (field === 1) {
                name = value.toString('utf8').toLowerCase();
              }

              // field 2 = domain (nested message)
              if (field === 2) {
                let di = 0;
                while (di < value.length) {
                  const dtag = value[di++];
                  const dfield = dtag >> 3;
                  const dwire = dtag & 7;

                  if (dfield === 1 && dwire === 2) {
                    let dlen;
                    [dlen, di] = readVarint(value, di);
                    domains.push(value.slice(di, di + dlen).toString('utf8'));
                    di += dlen;
                  } else {
                    di++;
                  }
                }
              }
            }

            if (!name || !safeName(name) || domains.length === 0) continue;

            const uniq = [...new Set(domains)].sort();

            const txt = [];
            const yaml = ['payload:'];

            for (const d of uniq) {
              txt.push(d);
              yaml.push(`  - +.${d}`);
            }

            fs.writeFileSync(`rules/geosite/${name}.txt`, txt.join('\n') + '\n');
            fs.writeFileSync(`rules/geosite/${name}.yaml`, yaml.join('\n') + '\n');
          }
          EOF

      - name: Build geosite MRS
        run: |
          for f in rules/geosite/*.txt; do
            name=$(basename "$f" .txt)
            mihomo convert-ruleset domain text \
              "$f" \
              "rules/geosite/$name.mrs" || true
          done

      # =========================
      # COMMIT
      # =========================
      - name: Commit & push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add rules/
          if git diff --staged --quiet; then
            echo "No changes"
          else
            git commit -m "chore: rebuild rules (geofileviewer-correct parsing)"
            git push
          fi
